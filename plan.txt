目前遇到的问题：
    1.我们的信号输出有问题，这个问题不是会卡死，而是并没有输出，因此需要检查管脚（首先）
    2.由于我们的信号是循环采样，采样的频率并不稳定，建议修改为使用定时器中断，但是也可以先试试修改完1之后看看效果

解决办法：
    针对问题2，届时将
            switch (work_mode) {
            case 0:
                mode_realtime(); // 模式1 波形实时显示
                break;
            case 1:
                mode_replay(); // 模式2 波形回放显示
                break;
            case 2:
                mode_measure(); // 模式3 测量
                break;
            default:
                break;
        }
        这一段代码加入固定周期的定时器中断即可
    

    调整：
        3.7：
            关闭了所有中断，以主函数循环形式继续运行，目的是优先解决不显示的问题
            调整的ALE的初始化，同时使ALE默认置1
            增加了片选时的ALE等待，10us
            修改了WR的等待，从3ms改为10us，减少了时间
            新定义了WR为P3.6管脚
            WR在研究过程中发现原理图上有非门，可能反了？可以参考一下前辈的代码（没看到）    到时候实机改一下比较合适

            修改了从6264中读取的函数，在chip_select增加了以下字段
            else if(select ==3){
                //选择从6264中读取，调整的是RD,选完之后直接返回
                RD = 0;
                delay_10us(1);
                RD = 1;
                return;
            }

            增加了WRRD的初始化


        3.8:
            对部分文件使用了格式化工具，比较美观
            修复手动控制的ALE WR RD
            删除IO.c  select.c以及测试文件（hello等）
            修改一切以上相关函数，使用XBYTE整合功能
            回放信号输出到DAC通道1:还没想好怎么处理地址逻辑，
                目前想的是
                1【从1000开始】
                这样比较安全，但是可读长度随机，万一刚读完一个循环就开始回放就gg；
                2【从1000+address_offset+1开始】
                但循环存储需要区分第一个循环和之后的循环，因为第一个循环address_offset之后的位置还没存东西）


        3.9:
            删除RDWR的重复定义
            初始化部分移入.h文件
                注意：.h中使用extern unsigned int gen_fre_counter; // DA波形生成计时器
                原因：如果你要写一个模块，fun.c、fun.h，如果你在这个模块里定义一个内部的全局变量（只在模块内是全局的），那么就直接定义和声明在fun.h中即可。
                但是如果你需要一个全局变量，在这个模块被其他地方引用的时候也能奏效的话，那么你应该在fun.c中定义，并在fun.h声明即可。
                无需在其他文件中声明和定义这个变量。如果只是在模块内使用，还是除了这一的问题的话，那么就定义成静态的。
            注释掉一些目前未使用的函数，防止占用内存
            修改debug函数，只用于显示模式与档位（目前只关心模式1下输出波形的种类档位，别的显示横杠）
            已经验证各个按键可正常识别，左右上下顺序为56780   1234
            已经验证模式选择和波形选择可以正常循环
            发现输出digit为基线值100，猜测初始amp=0导致
            修改了amp与fre的判定逻辑，amp1-4循环，fre1，2，4，8循环

                【建议】：可以添加一个全局变量Address_Flag，当模式一中的address_offset被置零时，flag置1，意为完成一次波形存储的循环
                若flag为1，则在模式2中的波形回放时，从1000-1fff循环
                若flag为0，则在波形回放时，从1000-address_offset之间循环
        
        3.9:
            针对刚刚的建议采取了实际行动的代码
            分别添加了如下代码，在main.c中加入了全局变量address_flag=0
                    mode1中

                    if (address_offset >= DA_LEN)
                    {
                        address_offset = 0;
                        address_flag = 1;
                    }

                    mode2中

                if(address_flag == 1){
                    if (replay_address_offset >= DA_LEN)
                    {
                        replay_address_offset = 0;
                    }
                    }else{
                        if (replay_address_offset >= address_offset)
                        {
                            replay_address_offset = 0;
                        }
                }
