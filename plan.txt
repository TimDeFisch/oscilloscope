目前遇到的问题：
    1.我们的信号输出有问题，这个问题不是会卡死，而是并没有输出，因此需要检查管脚（首先）
    2.由于我们的信号是循环采样，采样的频率并不稳定，建议修改为使用定时器中断，但是也可以先试试修改完1之后看看效果

解决办法：
    针对问题2，届时将
            switch (work_mode) {
            case 0:
                mode_realtime(); // 模式1 波形实时显示
                break;
            case 1:
                mode_replay(); // 模式2 波形回放显示
                break;
            case 2:
                mode_measure(); // 模式3 测量
                break;
            default:
                break;
        }
        这一段代码加入固定周期的定时器中断即可
    

    调整：
        3.7：
            关闭了所有中断，以主函数循环形式继续运行，目的是优先解决不显示的问题
            调整的ALE的初始化，同时使ALE默认置1
            增加了片选时的ALE等待，10us
            修改了WR的等待，从3ms改为10us，减少了时间
            新定义了WR为P3.6管脚
            WR在研究过程中发现原理图上有非门，可能反了？可以参考一下前辈的代码（没看到）    到时候实机改一下比较合适

            修改了从6264中读取的函数，在chip_select增加了以下字段
            else if(select ==3){
                //选择从6264中读取，调整的是RD,选完之后直接返回
                RD = 0;
                delay_10us(1);
                RD = 1;
                return;
            }

            增加了WRRD的初始化


        3.8:
            对部分文件使用了格式化工具，比较美观
            修复手动控制的ALE WR RD
            删除IO.c  select.c以及测试文件（hello等）
            修改一切以上相关函数，使用XBYTE整合功能
            回放信号输出到DAC通道1:还没想好怎么处理地址逻辑，
                目前想的是
                1【从1000开始】
                这样比较安全，但是可读长度随机，万一刚读完一个循环就开始回放就gg；
                2【从1000+address_offset+1开始】
                但循环存储需要区分第一个循环和之后的循环，因为第一个循环address_offset之后的位置还没存东西）


        3.9:
            删除RDWR的重复定义
            初始化部分移入.h文件
                注意：.h中使用extern unsigned int gen_fre_counter; // DA波形生成计时器
                原因：如果你要写一个模块，fun.c、fun.h，如果你在这个模块里定义一个内部的全局变量（只在模块内是全局的），那么就直接定义和声明在fun.h中即可。
                但是如果你需要一个全局变量，在这个模块被其他地方引用的时候也能奏效的话，那么你应该在fun.c中定义，并在fun.h声明即可。
                无需在其他文件中声明和定义这个变量。如果只是在模块内使用，还是除了这一的问题的话，那么就定义成静态的。
            注释掉一些目前未使用的函数，防止占用内存
            修改debug函数，只用于显示模式与档位（目前只关心模式1下输出波形的种类档位，别的显示横杠）
            已经验证各个按键可正常识别，左右上下顺序为56780   1234
            已经验证模式选择和波形选择可以正常循环
            发现输出digit为基线值100，猜测初始amp=0导致
            修改了amp与fre的判定逻辑，amp1-4循环，fre1，2，4，8循环
            已经修改以上问题，现在digit_buffer值正常并可以调节幅度和频率
            依然无法输出波形
            【特别注意】为了探究是否是DA转换器问题，暂时将CH1修改为【输出锯齿波】，详见代码。

              
        
        3.9:
            【建议】：可以添加一个全局变量Address_Flag，当模式一中的address_offset被置零时，flag置1，意为完成一次波形存储的循环
                若flag为1，则在模式2中的波形回放时，从1000-1fff循环
                若flag为0，则在波形回放时，从1000-address_offset之间循环
            针对刚刚的建议采取了实际行动的代码
            分别添加了如下代码，在main.c中加入了全局变量address_flag=0
                    mode1中

                    if (address_offset >= DA_LEN)
                    {
                        address_offset = 0;
                        address_flag = 1;
                    }

                    mode2中

                if(address_flag == 1){
                    if (replay_address_offset >= DA_LEN)
                    {
                        replay_address_offset = 0;
                    }
                    }else{
                        if (replay_address_offset >= address_offset)
                        {
                            replay_address_offset = 0;
                        }
                }


3.10
digit_Buffer----》unsigned char
使用单片机精灵修改了12MHz下10us延时函数，比ai可信

3.12
    - 把两排KEY对调了一下，现在按键功能和（错误的）丝印层对应，比较直观（有reset按键的那排是S1 ~ 4）
    - 更改DA固定波形数值，全调为正数，避免与unsigned char类型冲突
    - 启用timer0中断；把工作相关的操作放在定时器中断内执行，确保采样频率一致；在main的主循环中只进行键盘扫描判定

3.13
    复原了之前的测量函数，将amp,amp_mesured,amp_max,amp_min改为unsigned char，用于和Digital buffer对接(本来也是256)
    测量函数的思路：寻找连续的五个上升/下降点，连续的变化点被视为上升/下降沿，一个下降沿后的上升沿，视为一个周期
    问题：
        1.无法观测方波函数和斜波函数（也就是瞬间完成上升/下降变化的）
        2.无法观测复杂波形（但这个不在信号发生器产生的常规信号中，不作考虑）
    
    建议：
        1.目前的解决思路是，放弃连续五个上升下降，默认波形只有上升和下降，若波形上升过程中（即amp>amp_old）时，突然遇到了amp<amp_old的情况，则视为遇到了一个峰值
        遇到两个最大值之间的时间，即为一个周期


3.16
基线更改为128
考虑到1/4分频，系统时钟相关操作全部延时4倍
补充了测量函数的变量定义
修改了显示函数，原本的显示函数调用时间太长，会发生逐位显示的情况，目前使用debug函数进行显示，能快速更新。
取消了模式三的debug提示（原本led会显示3 空 空 空，现在直接进入参数显示），目的是防止测试受到干扰。

需求：
measure_flag用于选择显示什么参数（amp  fre）。因此还需要加一个按键决定：
// 模式3 测量
void mode_measure(void)
{
    // AD转化
    AD_get();
    // 信号特征提取
    measure_wavedata();
    // 信号特征显示
    if(measure_flag==0)//需要加一个按键选择显示什么参数
    {n=(int)amp_measured*1000;}//还没考虑小数点，小数点需要显示在第一位
    else
    {n=(int)fre_measured*10;}//还没考虑小数点，小数点需要显示在第三位
    debug((unsigned int)n/1000,((unsigned int)n/100)%10, (unsigned int)(n/10)%10, (unsigned int)n%10);
}

未进行输入波形测量测试，实验器材过于局限，建议在实验室进行
